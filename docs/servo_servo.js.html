<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: servo/servo.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: servo/servo.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Servo module - For controlling hobby servos
 * @module j5e/servo
 */
import { Emitter } from "../util/event.js";
import {normalizeParams, getProvider} from "../util/fn.js";

/** 
 * Class representing a Servo
 * @classdesc The Servo class allows for control of hobby servos
 * @extends Emitter
 * @fires Servo#move:complete - Fires when a servo reaches its requested position
 */
class Servo extends Emitter {
  
  #state = {
    history: [],
    isRunning: false,
    animation: null,
    value: null
  };

  /**
   * Instantiate a Servo
   * @param {(number|string|object)} io - A pin number, pin identifier or a complete IO options object
   * @param {(number|string)} [io.pin] - If passing an object, a pin number or pin identifier
   * @param {(string|constructor)} [io.io=builtin/digital] - If passing an object, a string specifying a path to the IO provider or a constructor
   * @param {object} [device={}] - An object containing device options
   * @param {string} [device.type="standard"] - Type of servo ("standard" or "continuous")
   * @param {number[]} [device.pwmRange=[600, 2400]] - The pulse width range in microseconds
   * @param {number[]} [device.deadband=[90,90]] - The range at which a continuos motion servo will not turn
   * @param {number[]} [device.range=[0, 180]] - The allowed range of motion in degrees
   * @param {number[]} [device.deviceRange=[0, 180]] - The physical range of the servo in degrees
   * @param {number} [device.startAt="Any value within device.range"] - The desired start position of the servo
   * @param {number} [device.offset=0] - Adjust the position of the servo for trimming
   * @param {boolean} [device.invert=false] - Reverses the direction of rotation
   * @param {boolean} [device.center=false] - Center the servo on instantiation
   * @property {object[]} history - The last five position updates
   * @property {object[]} history.timestamp - Timestamp of position update
   * @property {object[]} history.target - The user requested position
   * @property {object[]} history.degrees - The actual position (factors in offset and invert)
   * @property {object} last - The most recent position update
   * @property {object[]} last.timestamp - Timestamp of position update
   * @property {object[]} last.target - The user requested position
   * @property {object[]} last.degrees - The actual position (factors in offset and invert)
   */
  constructor(io, device) {
    return (async () => {
      const {ioOpts, deviceOpts} = normalizeParams(io, device);

      const Provider = await getProvider(ioOpts, "builtin/PWM");
      
      this.io = new Provider({
        pin: ioOpts.pin,
        mode: Provider.Output,
        hz: 50
      });
      
      this.#state.pwmRange = deviceOpts.pwmRange || [600, 2400];
      this.#state.deadband = deviceOpts.deadband || [90, 90];
      this.#state.offset = deviceOpts.offset || 0;
      this.#state.range = deviceOpts.range || [0 - this.offset, 180 - this.offset];
      this.#state.type = deviceOpts.type || "standard";
      this.#state.invert = deviceOpts.invert || false;

      Object.defineProperties(this, {
        history: {
          get: function() {
            return history.slice(-5);
          }
        },
        last: {
          get: function() {
            return history[history.length - 1];
          }
        },
        position: {
          get: function() {
            return history.length ? history[history.length - 1].degrees : -1;
          }
        }
      });

      return this;
    })();
  }

  // /**
  //  * Internal method that writes the current LED value to the IO
  //  */
  // write() {
  //   let value = constrain(this.#state.value, this.LOW, this.HIGH);

  //   if (this.#state.sink) {
  //     value = this.HIGH - value;
  //   }

  //   this.io.write(value | 0);
  // }

  // /**
  //  * Turn an led on
  //  * @return {Led}
  //  */
  // on() {
  //   this.#state.value = this.HIGH;
  //   this.write();
  //   return this;
  // }

  // /**
  //  * Turn an led off
  //  * @return {Led}
  //  */
  // off() {
  //   this.#state.value = this.LOW;
  //   this.write();
  //   return this;
  // }

  // /**
  //  * Toggle the on/off state of an led
  //  * @return {Led}
  //  */
  // toggle() {
  //   return this[this.isOn ? "off" : "on"]();
  // }

  // /**
  //  * Blink the LED on a fixed interval
  //  * @param {Number} duration=100 - Time in ms on, time in ms off
  //  * @param {Function} callback - Method to call on blink
  //  * @return {Led}
  //  */
  // blink(duration=100, callback) {
  //   // Avoid traffic jams
  //   this.stop();

  //   if (typeof duration === "function") {
  //     callback = duration;
  //     duration = 100;
  //   }

  //   this.#state.isRunning = true;

  //   this.#state.interval = timer.setInterval(() => {
  //       this.toggle();
  //     if (typeof callback === "function") {
  //       callback();
  //     }
  //   }, duration);

  //   return this;
  // }

  // /**
  //  * Set the brightness of an led attached to PWM
  //  * @param {Integer} value - Brightness value [this.HIGH, this.LOW]
  //  * @return {Led}
  //  */
  // brightness(value) {
  //   this.#state.value = value;
  //   this.io.write(value);
  //   return this;
  // }

  // /**
  // * Animate the brightness of an led. THis method is not meant to be called externally
  // * @param {Object} opts
  // * @param {function} opts.step - A callback to be run each time the LED state changes
  // * @param {function} opts.delta - A function that calculate each step's change
  // * @param {function} opts.complete - A function to call on completion
  // * @param {number} opts.duration=1000 - Duration of the animation in ms
  // * @param {number} opts.delay=10 - Interval delay in ms
  // * @return {Led}
  // */
  // animate(opts) {
  //   var start = Date.now();

  //   // Avoid traffic jams
  //   if (this.#state.interval) {
  //     timer.clearInterval(this.#state.interval);
  //   }

  //   if (!opts.duration) {
  //     opts.duration = 1000;
  //   }

  //   if (!opts.delta) {
  //     opts.delta = function(val) {
  //       return val;
  //     };
  //   }

  //   this.#state.isRunning = true;

  //   this.#state.interval = timer.setInterval(() => {
  //     const lapsed = Date.now() - start;
  //     let progress = lapsed / opts.duration;

  //     if (progress > 1) {
  //       progress = 1;
  //     }

  //     const delta = opts.delta(progress);

  //     opts.step(delta);

  //     if (progress === 1) {
  //       if (typeof opts.complete === "function") {
  //         opts.complete();
  //       }
  //     }
  //   }, opts.delay || 10);

  //  return this;
  // }

  // /**
  //  * Pulse the Led in and out in a loop with specified time
  //  * @param {number} [time=1000] Time in ms that a fade in/out will elapse
  //  * @param {function} [callback] A function to run each time the direction of pulse changes
  //  * @return {Led}
  //  */

  // pulse(time=1000, callback) {
    
  //   const target = this.#state.value !== 0 ?
  //     (this.#state.value === this.HIGH ? 0 : this.HIGH) : this.HIGH;
  //   const direction = target === this.HIGH ? 1 : -1;
  //   const update = this.#state.value &lt;= target ? target : (this.#state.value - target);

  //   if (typeof time === "function") {
  //     callback = time;
  //     time = 1000;
  //   }

  //   const step = (delta) => {
  //     let value = (update * delta);

  //     if (direction === -1) {
  //       value = value ^ this.HIGH;
  //     }

  //     this.#state.value = value;
  //     this.#state.direction = direction;
  //     this.write();
  //   };

  //   const complete = () => {
  //     this.pulse(time, callback);
  //     if (typeof callback === "function") {
  //       callback();
  //     }
  //   };

  //   return this.animate({
  //     duration: time,
  //     complete: complete,
  //     step: step
  //   });
  // }  

  // /**
  //  * fade Fade an led in and out
  //  * @param {Number} val Target brightness value
  //  * @param {Number} [time=1000] Time in ms that a fade will take
  //  * @param {function} [callback] A function to run when the fade is complete
  //  * @return {Led}
  //  */
  // fade(val, time=1000, callback) {
  //   const previous = this.#state.value || 0;
  //   const update = val - this.#state.value;

  //   if (typeof time === "function") {
  //     callback = time;
  //     time = 1000;
  //   }

  //   const step = (delta) => {
  //     const value = previous + (update * delta);
  //     this.#state.value = value;
  //     this.write();
  //   };

  //   const complete = () => {
  //     if (typeof callback === "function") {
  //       callback();
  //     }
  //   };
  //   return this.animate({
  //     duration: time,
  //     complete: complete,
  //     step: step
  //   });
  // }

  // /**
  //  * fade Fade an led in
  //  * @param {Number} [time=1000] Time in ms that a fade will take
  //  * @param {function} [callback] A function to run when the fade is complete
  //  * @return {Led}
  //  */
  // fadeIn(time=1000, callback) {
  //   return this.fade(this.HIGH, time, callback);
  // }

  // /**
  //  * fade Fade an led out
  //  * @param {Number} [time=1000] Time in ms that a fade will take
  //  * @param {function} [callback] A function to run when the fade is complete
  //  * @return {Led}
  //  */
  // fadeOut(time=1000, callback) {
  //   return this.fade(this.LOW, time, callback);
  // }

  // /**
  //  * stop Stop the led from strobing, pulsing or fading
  //  * @return {Led}
  //  */
  // stop() {
    
  //   if (this.#state.interval) {
  //     timer.clearInterval(this.#state.interval);
  //   }

  //   this.#state.interval = null;
  //   this.#state.isRunning = false;

  //   return this;
  // };

};

export default Servo;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-j5e_event.html">j5e/event</a></li><li><a href="module-j5e_fn.html">j5e/fn</a></li><li><a href="module-j5e_led.html">j5e/led</a></li><li><a href="module-j5e_servo.html">j5e/servo</a></li><li><a href="module-j5e_switch.html">j5e/switch</a></li></ul><h3>Classes</h3><ul><li><a href="module-j5e_event.Emitter.html">Emitter</a></li><li><a href="module-j5e_led-Led.html">Led</a></li><li><a href="module-j5e_servo-Servo.html">Servo</a></li><li><a href="module-j5e_switch-Switch.html">Switch</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Nov 13 2019 19:18:31 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
